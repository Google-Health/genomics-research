# Copyright 2021 Google LLC.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""Utilities and helper functions."""

import os
from typing import Any, Callable, List, Text
import pandas as pd


def load_csv(path, **kwargs) -> pd.DataFrame:
  """Loads a CSV using pandas.

  Args:
    path: A file path or a file-like object.
    **kwargs: Additional keyword arguments passed to pd.read_csv().

  Returns:
    A dataframe containing the given file.
  """
  if isinstance(path, str):
    with open(path) as f:
      return pd.read_csv(f, **kwargs)
  else:
    # `path` is a file-like object, so just pass directly to pandas.
    return pd.read_csv(path, **kwargs)


def get_file_name(file_path: Text) -> Text:
  """Extracts and returns the file name from the given file path."""
  return os.path.basename(file_path)


def convert_categorical_to_binary(df: pd.DataFrame, col_bin: Text,
                                  col_cat: Text,
                                  drop_cols: List[Text]) -> pd.DataFrame:
  """Converts a k-ary prob `1 = c_1 + c_2 + ...

  + c_k` to a binary prob.

  Represents One-vs-rest. For example, consider the following trinary prob
  `1 = PROB_HIGH + PROB_MED + PROB_LOW`. To create a new binary prob for
  `PROB_NOT_LOW`, which represents `PROB_NOT_LOW = 1 - PROB_LOW` we run
  `convert_categorical_to_binary(df, 'PROB_NOT_LOW', 'PROB_LOW',
  ['PROB_HIGH', 'PROB_MED'])`.

  Args:
    df: A dataframe containing col_cat and columns in drop_cols.
    col_bin: The name for the new column, represents the new binary column
      where`col_bin = 1 - col_cat`.
    col_cat: The name of an existing categorical column, used to calculate the
      value of the new `col_bin`.
    drop_cols: A list of columns to drop.

  Returns:
    A dataframe containing updated columns.

  Raises:
    ValueError if the col_cat or drop_cols do not exist or if col_bin already
      exists.
  """
  for col in drop_cols + [col_cat]:
    if col not in df.columns:
      raise ValueError('Column does not exist: {}'.format(col))

  if col_bin in df.columns:
    raise ValueError('Column already exists: {}'.format(col_bin))

  df[col_bin] = 1.0 - df[col_cat]
  return df.drop(columns=drop_cols)


def drop_col_below_threshold(df, drop_col, lower_bound=0.7):
  """Drops any rows where df[drop_col] < lower_bound.

  Args:
    df: A dataframe.
    drop_col: The column used to filter values.
    lower_bound: The lower bound for dropping rows based on their value in
      drop_col.

  Returns:
    A dataframe with updated rows.

  Raises:
    AssertionError if not 0 < lower_bound < 1.
  """
  assert 0 < lower_bound < 1, 'Invalid lower_bound: {}.'.format(lower_bound)
  return df.loc[df[drop_col] >= lower_bound]


def append_col_with_map(df: pd.DataFrame, src_col: Text, dst_col: Text,
                        func: Callable[[Any], Any]) -> None:
  """Appends a new `dst_col` column on the dataframe `df` using map.

  Args:
    df: A pandas dataframe.
    src_col: The name of the column that is mapped from.
    dst_col: The name of the new column generated by the map.
    func: A function applied to the src_col.

  Returns:
    None.
  """
  df[dst_col] = df[src_col].map(func)


def load_predictions(preds_csv, cols_to_use, **kwargs):
  """Loads model predictions and does preprocessing."""
  # the predictions file should have all of these columns

  preds = load_csv(preds_csv, usecols=cols_to_use, **kwargs)
  append_col_with_map(preds, 'image_id', 'file_name', get_file_name)
  preds = preds.drop(columns='image_id')

  # Create a `gradability` weight that corresponds to GRADABLE + WITH_DIFFICULTY
  preds = convert_categorical_to_binary(
      preds, 'gradability', 'glaucoma_gradability:UNGRADABLE', [
          'glaucoma_gradability:UNGRADABLE',
          'glaucoma_gradability:WITH_DIFFICULTY',
          'glaucoma_gradability:GRADABLE',
      ])

  # Create a `vertical_cd_visibility` weight that corresponds to
  # SUFFICIENT + COMPROMISED
  preds = convert_categorical_to_binary(
      preds, 'vertical_cd_visibility',
      'vertical_cd_visibility:UNABLE_TO_ASSESS', [
          'vertical_cd_visibility:SUFFICIENT',
          'vertical_cd_visibility:COMPROMISED',
          'vertical_cd_visibility:UNABLE_TO_ASSESS',
      ])

  # Create a `vertical_cup_to_disc` real value
  preds = preds.rename(columns={
      'vertical_cup_to_disc:VERTICAL_CUP_TO_DISC': 'vertical_cup_to_disc',
  })

  # Create a `glaucoma_risk_likely` risk prob that equals LIKELY
  preds['glaucoma_risk'] = preds['glaucoma_suspect_risk:LIKELY']

  return preds


def extract_attributes_from_image_path(path):
  """Returns a tuple of (EID, eye, visit, index) from a valid image path.

  Args:
    path: str. The string path of the image.

  Returns:
    A tuple of (EID: int, eye: int, visit: int, index: int)
    of the image.

  Raises:
    ValueError: The path is not a valid path encoding the information.
  """
  basename = os.path.basename(path)
  streid, eyeid, visitid, indexix_plus_suffix = basename.split('_')
  try:
    eid = int(streid)
    visit = int(visitid)
    indexix = int(indexix_plus_suffix.split('.')[0])
  except ValueError:
    raise ValueError('Invalid image path {}'.format(path))

  # See http://biobank.ndph.ox.ac.uk/showcase/field.cgi?id=21015 and
  # http://biobank.ndph.ox.ac.uk/showcase/field.cgi?id=21016
  if eyeid == '21015':
    eye = 1
  elif eyeid == '21016':
    eye = 2
  else:
    raise ValueError('Invalid eye in {}: {}'.format(path, eyeid))

  if not 0 <= visit < 2:
    raise ValueError('Unexpected visit in {}: {}'.format(path, visit))
  if not 0 <= indexix < 2:
    raise ValueError('Unexpected index in {}: {}'.format(path, indexix))

  return (eid, eye, visit, indexix)
